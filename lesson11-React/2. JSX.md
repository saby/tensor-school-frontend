# JSX
JSX — расширение языка JavaScript.
JSX напоминает язык шаблонов, наделённый силой JavaScript.
```jsx
const element = <h1>Привет, мир!</h1>;
```

## Что такое JSX?
React исходит из принципа, что логика рендеринга неразрывно связана с прочей
логикой UI: с тем, как обрабатываются события, как состояние изменяется во времени и
как данные готовятся к отображению.
Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику
в разные файлы, React разделяет ответственность с помощью слабо связанных единиц,
называемых «компоненты», которые содержат и разметку, и логику.

React можно использовать и без JSX, но большинство людей ценит его за наглядность
при работе с UI, живущем в JavaScript-коде.
Помимо этого, JSX помогает React делать сообщения об ошибках и предупреждениях понятнее.
Например, показывать положение компонента в приложении:

![alt-ошибка в компоненте react][error-example]

## Встраивание выражений в JSX
В следующем примере мы объявляем переменную name и затем используем её внутри JSX,
обрамляя фигурными скобками:

```jsx
const name = 'Иван-Царевич';
const element = <h1>Здравствуй, {name}!</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

JSX допускает использование любых корректных JavaScript-выражений внутри фигурных
скобок. Например, ```2 + 2```, ```user.firstName``` и ```formatName(user)```
являются допустимыми выражениями.

В примере ниже мы встраиваем результат вызова JavaScript-функции ```formatName(user)```
в элемент ```<h1>```:

```jsx
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Марья',
  lastName: 'Моревна'
};

const element = (
  <h1>
    Здравствуй, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

Чтобы улучшить читаемость, мы разбили JSX на несколько строк. В таких случаях,
хотя это и не обязательно, мы советуем заключать всё выражение целиком в круглые
скобки, чтобы избежать проблем, связанных с автоматической вставкой точек с запятой.

## Использование JSX в внутри JS выражений
После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции,
результат которого — объект JavaScript.

Из этого следует, что JSX можно использовать внутри выражений if и циклов for,
присваивать переменным, передавать функции в качестве аргумента и возвращать из
функции.

```jsx
function getGreeting(user) {
  if (user) {
    return <h1>Здравствуй, {formatName(user)}!</h1>;
  }
  return <h1>Здравствуй, незнакомец.</h1>;
}
```

### JSX представляет собой объекты
При сборке приложения JSX элементы преобразуются в вызовы
```jsx()```.

Следующие два примера кода эквивалентны между собой:
```jsx
const element = (
  <h1 className="greeting">
    Привет, мир!
  </h1>
);
```
```jsx
import {jsx} from 'react';
const element = jsx(
  'h1',
  {className: 'greeting', children: 'Привет, мир!'}
);
```

```jsx()``` создаёт объект похожий на такой:

```js
// Примечание: этот код несколько упрощён.
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Привет, мир!'
  }
};
```

Эти объекты называются React-элементами. Можно сказать, что они описывают результат,
который мы хотим увидеть на экране.
React читает эти объекты и использует их, чтобы конструировать и поддерживать DOM.

## Использование атрибутов JSX
Чтобы использовать строковый литерал в качестве значения атрибута, используются
кавычки:

```jsx
const element = <div tabIndex="0"></div>;
```

Если же в значении атрибута требуется указать JavaScript-выражение, то на помощь
приходят фигурные скобки:

```jsx
const element = <img src={user.avatarUrl}></img>;
```

Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение
в значении атрибута. Следует либо применить кавычки (для строковых литералов),
либо фигурные скобки (для выражений), но не то и другое вместе.

### Различия в атрибутах
Самое большое отличие React от HTML &ndash; в React атрибуты указываются в camelCase, например, вместо `tabindex` нужно писать `tabIndex`.

Есть ряд атрибутов, которые по-разному работают в React и HTML:
#### className
Чтобы указать класс CSS, используйте атрибут ```className```.
Это относится ко всем обычным элементам DOM и SVG, таким как ```<div>```, ```<a>```
и т. д.

Если вы используете React с веб-компонентами (что встречается редко), используйте
вместо этого атрибут ```class```.

#### dangerouslySetInnerHTML
Свойству ```innerHTML``` в DOM браузера соответствует ```dangerouslySetInnerHTML```
в React.
Как правило, вставка HTML из кода рискованна, так как можно случайно подвергнуть
ваших пользователей атаке межсайтового скриптинга.
Таким образом, вы можете вставить HTML непосредственно из React используя
```dangerouslySetInnerHTML``` и передать объект с ключом ```__html```,
чтобы напомнить себе, что это небезопасно. Например:

```jsx
function createMarkup() {
  return {__html: 'Первый &middot; Второй'};
}

function MyComponent() {
  return <div dangerouslySetInnerHTML={createMarkup()} />;
}
```

Тем не менее его можно использовать для взаимодействия с внешними библиотеками
и фреймворками

```jsx
class MarkdownEditor extends React.Component {
    
  getRawMarkup() {
    const md = new Remarkable();
    return { __html: md.render('Привет, **мир**!') };
  }

  render() {
    return (
      <div className="MarkdownEditor">
        <label htmlFor="markdown-content">
          Что-то в формате Markdown
        </label>
        <div
          className="content"
          dangerouslySetInnerHTML={this.getRawMarkup()}
        />
      </div>
    );
  }
}

ReactDOM.render(
  <MarkdownEditor />,
  document.getElementById('root')
);
```

#### style
Атрибут style принимает JavaScript-объект со свойствами в camelCase вместо CSS-строк.
Такой подход повышает эффективность и защищает от XSS. Например:

```jsx
const divStyle = {
  color: 'blue',
  backgroundImage: 'url(' + imgUrl + ')',
};

function HelloWorldComponent() {
  return <div style={divStyle}>Привет, мир!</div>;
}
```

React автоматически добавит суффикс «px» к свойствам стилей с числовым значением.
Если вы хотите использовать единицы измерения, отличные от «px», укажите значение в
виде строки с желаемой единицей измерения. Например:

```jsx
// Результат: '10px'
<div style={{ height: 10 }}>
  Привет, мир!
</div>

// Результат: '10%'
<div style={{ height: '10%' }}>
  Привет, мир!
</div>
```

Однако не все свойства стилей преобразуются в пиксельные строки. Некоторые из них
остаются без единиц (например, zoom, order, flex).

#### value
Атрибут value поддерживается компонентами ```<input>```, ```<select>``` и ```<textarea>```.
Он устанавливает значение компонента.
Это полезно для создания управляемых компонентов.
```defaultValue``` — это неуправляемый эквивалент, который устанавливает значение
компонента во время первого монтирования.


## Использование дочерних элементов в JSX
Если тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:

```jsx
const element = <img src={user.avatarUrl} />;
```

Но JSX-теги могут и содержать дочерние элементы:

```jsx
function getGreeting(user) {
    if (user) {
        return <h1>Здравствуй, {formatName(user)}!</h1>;
    }
    return <h1>Здравствуй, незнакомец.</h1>;
}

const element = (
  <div>
      {getGreeting()}
      <h2>Рады вас видеть.</h2>
  </div>
);
```

Часто это бывает полезно при рендере списка JSX-выражений произвольной длины.
Например, этот код отрисовывает список:

```jsx
function Item(props) {
  return <li>{props.message}</li>;
}

function TodoList() {
  const todos = ['закончить документацию', 'отправить пулреквест', 'снова напомнить Дэну про ревью'];
  return (
    <ul>
      {todos.map((message) => <Item message={message} />)}
    </ul>
  );
}
```

### Логические значения, null и undefined игнорируются

Значения ```false```, ```null```, ```undefined``` и ```true``` — валидные дочерние компоненты.
Просто они не рендерятся. Эти JSX-выражения будут рендерить одно и то же:

```jsx
<div />

<div></div>

<div>{false}</div>

<div>{null}</div>

<div>{undefined}</div>

<div>{true}</div>
```

Этот подход может быть полезным для рендера по условию.
Вот пример, где JSX рендерит `<Header />`, если `showHeader` равняется `true`:

```jsx
<div>
  {showHeader && <Header />}
  <Content />
</div>
```

Есть один нюанс в том, что React будет рендерить «ложные» (`falsy`) значения, такие как число `0`.
Код ниже ведёт себя не так, как вы могли ожидать, так как `0` будет отображён, если массив `props.messages` пуст:

```jsx
<div>
  {props.messages.length &&
    <MessageList messages={props.messages} />
  }
</div>
```

Чтобы исправить это, убедитесь что выражение перед оператором `&&` всегда является boolean:
```jsx
<div>
  {props.messages.length > 0 &&
    <MessageList messages={props.messages} />
  }
</div>
```

И наоборот, если вы хотите, чтобы такие значения как `false`, `true`, `null` или `undefined` отрисовались,
то сначала вы должны преобразовать их в строку:

```jsx
<div>
  Моя переменная JavaScript - {String(myVariable)}.
</div>
```

### React.Fragment

Компонент ```React.Fragment``` позволяет возвращать несколько элементов без
создания дополнительного корневого элемента DOM:

```jsx
const element = (
    <React.Fragment>
      Какой-то текст.
      <h2>Заголовок</h2>
    </React.Fragment>
  );
```

Вы также можете использовать его сокращённый синтаксис ```<></>```.

```jsx
// эквивалентно предыдущей записи
const element = (
    <>
        Какой-то текст.
        <h2>Заголовок</h2>
    </>
);
```
## JSX предотвращает атаки, основанные на инъекции кода
Данные, введённые пользователем, можно безопасно использовать в JSX:

```jsx
const title = response.potentiallyMaliciousInput;
// Этот код безопасен:
const element = <h1>{title}</h1>;
```

По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как
отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо,
что не было явно написано в вашем приложении. Всё преобразуется в строчки,
перед тем как быть отрендеренным.
Это помогает предотвращать атаки межсайтовым скриптингом (XSS).

[error-example]: ./2.%20JSX/error_example.png
