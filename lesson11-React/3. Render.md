# Рендеринг JSX

Ранее мы рассмотрели как выглядит основной синтаксис JSX.
Он описывает то, что вы хотите увидеть в браузере.
При рендере React преобразовывает JSX в легковесные аналоги DOM-элементов,
а ReactDOM обновляет DOM, чтобы он соответствовал полученным React-элементам.

> Элементы React — аналоги HTML-элементов в среде React.

Чтобы отрендерить JSX необходимо чтобы в нашем HTML-файле был «корневой» узел DOM, так как
ReactDOM будет управлять его содержимым. Например: ```<div id="root"></div>```.

Обычно в приложениях, написанных полностью на React, есть только один корневой элемент.
При встраивании React в существующее приложение вы можете рендерить во столько независимых
корневых элементов, во сколько посчитаете нужным.

Для рендеринга React-элемента в корневой узел DOM вызовите ```ReactDOM.render()```
с React-элементом и корневым DOM-узлом в качестве аргументов:

```jsx 
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

## Обновление JSX

Элементы React иммутабельны.
После создания элемента нельзя изменить его потомков или атрибуты.
Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.

Пока что, мы знаем только один способ обновить интерфейс —
это создать новый элемент и передать его в ```ReactDOM.render()```.

Рассмотрим пример с часами:

```jsx
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);
```

В этом примере ```ReactDOM.render()``` вызывается каждую секунду с помощью колбэка setInterval().

**React обновляет только то, что необходимо**

React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только
минимально необходимые изменения.

![alt-Обновление DOM][dom_update]

## Компоненты и пропсы

Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности.
Их можно сочетать друг с другом и использовать несколько раз.

Во многом компоненты ведут себя как обычные функции JavaScript.
Они принимают произвольные входные данные (так называемые «пропсы») и возвращают
React-элементы, описывающие, что мы хотим увидеть на экране.

### Функциональный компонент

Проще всего объявить React-компонент как функцию:
```jsx
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```
Эта функция — компонент, потому что она получает данные в одном объекте («пропсы»)
в качестве параметра и возвращает React-элемент.
Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.

### Рендеринг компонента
Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в
один объект и передаёт их нашему компоненту. Этот объект называется «пропсы» (props).

Например, этот компонент выведет «Привет, Мир» на страницу:
```jsx
const element = <Welcome name="Мир" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

Давайте разберём, что именно здесь происходит:
  1. Мы передаём React-элемент ```<Welcome name="Мир" />``` в ```ReactDOM.render()```.
  1. React вызывает наш компонент ```Welcome``` с пропсами ```{name: 'Мир'}```.
  1. Наш компонент Welcome возвращает элемент ```<h1>Привет, Мир</h1>``` в качестве результата.
  1. React DOM делает минимальные изменения в DOM, чтобы получилось ```<h1>Привет, Мир</h1>```.

### Пропсы можно только читать

Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того,
функциональный он или классовый.

Возьмём для примера функцию sum:

```js
function sum(a, b) {
  return a + b;
}
```

Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо
возвращают один и тот же результат для одинаковых аргументов.

А вот пример нечистой функции — она записывает данные в свои же аргументы:

```js
function withdraw(account, amount) {
  account.total -= amount;
}
```

React достаточно гибкий, но есть одно правило, которое нельзя нарушать:

***React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.*** 

***Пропсы неизменны.***

### Композиция компонентов

Компоненты можно использовать внутри других компонентов.
Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне
нашего приложения.
Неважно, пишем ли мы кнопку, форму или целый экран: все они, как правило, представляют
собой компоненты в React-приложениях.

Например, компонент App может отрендерить компонент Welcome несколько раз:

```jsx
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Мир" />
      <Welcome name="Труд" />
      <Welcome name="Май" />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```

В приложениях, написанных на React с нуля, как правило, есть один компонент ```App```,
который находится на самом верху.

В случае, если вы переписываете существующее приложение на React,
имеет смысл начать работу с маленького компонента типа ```Button``` и
постепенно двигаться «вверх» по иерархии.

## Состояние и жизненный цикл компонента

Мы разобрались как описать и отрендерить компонент, а так же, как его обновить,
но обновление компонента извне не самая лучшая идея.
Обычно логика обновления инкапсулируется внутри него.

В React это делается с помощью состояния и методов жизненного цикла.
>**Состояние** — объект внутри компонента, содержащий данные необходимые для его рендера.

Объект состояния может изменяться самим компонентом в отличие от пропсов, в него можно
записать результаты удаленного вызова или результаты внутренних вычислений.

### Преобразуем верстку в компонент
Покажем на примере часов, как инкапсулировать логику в компоненте.

Для начала, создадим компонент, показывающий время:

```jsx
function Clock(props) {
  return (
    <div>
      <h1>Привет, мир!</h1>
      <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

Так мы все еще обновляем DOM-дерево извне, а в идеале это должна быть зона ответственности
компонента и для его включения нужно было всего лишь:

```jsx
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

### Используем состояние
Управлять состоянием функционального
компонента можно с помощью специальных функций &ndash; хуков.
Воспользуемся хуком `useState` для внедрения логики использования даты
  1. Импортируем хук `useState` из `react`:
```jsx
import { useState } from 'react';
```
  2. Объявим начальное состояние в компоненте перед возвратом JSX
```jsx
function Clock(props) {
    // начальное состояние useState(initalState); 
    const [date, setDate] = useState(new Date());
    // return ...
}
```

  3. Заменим ```props.date``` на переменную ```date```
     и удалим `props` из компонента и `ReactDOM.render()`:
```jsx
function Clock() {
  const [date, setDate] = useState(new Date());
  return (
    <div>
      <h1>Привет, мир!</h1>
      <h2>Сейчас {date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock />,
    document.getElementById('root')
  );
}
```

Мы получили компонент, который использует состояние, но не меняет его.
Для изменения состояния воспользуемся другим хуком &ndash; `useEffect`.

### Используем хук useEffect()
Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting).
Нам нужно устанавливать таймер всякий раз, когда это происходит.

Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting).
Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».
Для начала необходимо добавить хук в импорт:

```jsx
import { useState, useEffect } from 'react';
```

Хук `useEffect()` запускается после того, как компонент отрендерился в DOM
— здесь мы и установим таймер:

```jsx
function Clock() {
     const [date, setDate] = useState(new Date());
     useEffect(() => {
          const timerId = setTimeout(() => setDate(new Date()), 1000);
     });
     // return ...
}
```

Теперь нам нужно сбросить таймер при удалении компонента из DOM-дерева, чтобы
избежать утечки памяти на странице &ndash; для этого вернем функцию отмены эффекта из хука
useEffect():
```jsx
  useEffect(() => {
    const timerId = setTimeout(() => setDate(new Date()), 1000);
    return () => {
      clearTimeout(timerId);
    };
  });
```

Теперь часы обновляются каждую секунду, но по умолчанию хук `useEffect()`
применяется каждый раз при обновлении компонента (изменение пропов или состояния).
Чтобы нам не устанавливать и удалять таймер каждую секунду при изменении даты,
добавим опциональный аргумент `dependencies` в хук `useEffect(effect, [dependencies])`:
```jsx
useEffect(() => {
    const timerId = setTimeout(() => setDate(new Date()), 1000);
    return () => {
      clearTimeout(timerId);
    }
  }, [])
```
В этом примере у таймера нет зависимостей от пропов или стейта, поэтому эффект будет
применен при монтировании компонента, а удален при размонтировании.
Итог:
```jsx
import ReactDOM from "react-dom";
import { useState, useEffect } from "react";

function Clock() {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerId = setTimeout(() => setDate(new Date()), 1000);
    return () => {
      clearTimeout(timerId);
    }
  }, []);
  return (
    <div>
      <h1>Привет, мир!</h1>
      <h2>Сейчас {date.toLocaleTimeString()}.</h2>
    </div>
  );
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

> `dependencies` &ndash; это массив переменных, которые влияют на эффект.

При указании зависимостей эффекта при каждом обновлении текущий набор зависимостей
будет сравниваться с предыдущим, если что-то поменялось, то старый эффект будет отменен,
а новый применен. Работая с пустым набором зависимостей при каждом рендере ничего
не меняется, поэтому эффект применяется всего 1 раз.
  * **Если зависимости не указаны &ndash; эффект применяется при каждом рендере**
  * **Пустые зависимости &ndash; эффект применяется 1 раз**
  * **Указан набор зависимостей &ndash; эффект применяется при изменении одной из зависимостей**

При использовании этого хука почти всегда необходимо указывать переменные, используемые
внутри эффекта. Например:
```jsx
function User(props) {
    useEffect(() => {
        loadUserInfo(props.userId);
    }, [props.userId])
}
```
Загрузка данных пользователя будет происходить при смене идентификатора переданного
в компонент.

### Создадим пользовательский хук
Использование хуков позволяет повторно использовать логику в различных компонентах.
Необходимо понимать, что **использование одних и тех же хуков** для разных компонентов
**создает независимые эффекты и состояния** для каждого компонента.

Допустим, вам необходимо раз в секунду обновлять не только цифровые часы, но и
циферблат со стрелками. Для этого мы можем воспользоваться логикой часов, выделив
ее в пользовательский хук.
> По соглашению в React все хуки начинаются со слова `use` и пишутся в camelCase &ndash; `useClock()`

  1. Перенесем использование хуков в отдельную функцию `useClock()`:
```jsx
function useClock() {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerId = setTimeout(() => setDate(new Date()), 1000);
    return () => {
      clearTimeout(timerId);
    };
  }, []);
}
```
  2. Вернем из пользовательского хука состояние `date`:
```jsx
function useClock() {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerId = setTimeout(() => setDate(new Date()), 1000);
    return () => {
      clearTimeout(timerId);
    };
  }, []);
  return date;
}
```
  3. Воспользуемся нашим хуком в компоненте:
```jsx
function Clock() {
  const date = useClock();
  return (
    <div>
      <h1>Привет, мир!</h1>
      <h2>Сейчас {date.toLocaleTimeString()}.</h2>
    </div>
  );
}
```

  4. *Для отладки в пользовательский хук можно добавить использование `useDebugValue()`,
Состояние хука будет проще найти в [React DevTools]([react_devtools]).
```jsx
useDebugValue(date);
```

С полным набором хуков можно ознакомиться в [документации]([hooks_doc])

### Как работает компонент
Давайте рассмотрим наше решение и разберём порядок, в котором вызываются методы:

  1. Когда мы передаём ```<Clock />``` в ```ReactDOM.render()```, React вызывает
     функцию рендера компонента. ```Clock``` должен отображать текущее время, поэтому мы задаём
     начальное состояние ```useState(new Date())``` с текущим временем и создаем
     эффект с таймером для обновления часов `useEffect()`. По начальному состоянию
     создается JSX-элемент и React создает первоначальную верстку компонента.
  1. После прикрепления компонента к DOM-дереву создается эффект c таймером, который
     был указан внутри `useEffect()`.
  1. Раз в секунду срабатывает колбэк таймера и устанавливается новая дата через
     `setDate()`. Здесь повторно вызывается метод рендера и задействуются хуки,
     `useState()` не будет заново устанавливать инициализирующее значение, а
     `useEffect()` применится заново только если изменились зависимости или их нет вообще.
  1. Если компонент ```Clock``` когда-либо удалится из DOM, `useEffect()` вызовет
     метод полученный в результате установки и сбросит таймер.

![alt-схема работы часов][clock_scheme]

### Однонаправленный поток данных
В иерархии компонентов ни родительский, ни дочерние компоненты не знают задано ли состояние другого компонента.

Состояние часто называют «локальным», «внутренним» или «инкапсулированным».
Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов
дочерних компонентов (есть и другие способы передачи данных, их мы
затронем чуть позже):

```jsx
<FormattedDate date={this.state.date} />
```

Компонент `FormattedDate` получает `date` через пропсы, но он не знает,
откуда они взялись изначально — из состояния `Clock`, пропсов `Clock` или
просто JavaScript-выражения:

```jsx
function FormattedDate(props) {
  return <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>;
}
```

Это называется «нисходящим» («top-down») или «однонаправленным»
(«unidirectional») потоком данных.
Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.

Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.

В React-приложениях имеет компонент состояние или нет — это внутренняя деталь реализации компонента, которая может меняться со временем. Можно использовать компоненты без состояния в компонентах с состоянием, и наоборот.

[dom_update]: ./3.%20Render/dom_update.gif
[clock_scheme]: ./3.%20Render/clock_scheme.png
[detailed_article]: https://ru.reactjs.org/docs/react-component.html
[react_devtools]: https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi
[hooks_doc]: https://ru.reactjs.org/docs/hooks-reference.html
