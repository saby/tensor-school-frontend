# setTimeout и setInterval

Теперь, зная как JS работает с макрозадачами, рассмотрим прикладное применение, на примере setTimeout и setInterval.

Web платформа предоставляет языку JavaScript несколько функций позволяющих выполнять код асинхронно после определенного интервала времени, и многократно выполнять блок кода асинхронно, пока выполнение не будет остановлено.

```javascript
    setTimeout(callback[, timeout, ...args]) // Выполняет определенный блок кода единожды, после завершения указанного времени.
    setInterval(callback[, timeout, ...args]) //Выполняет определенный блок кода многократно с определенной временной задержкой между каждым вызовом.
```

Аргументы принимаемые этими функциями:

* Функция или ссылка на функцию
* Число в миллисекундах, определяющее задержку вызова функций. Если передать 0 или опустить значение, функция будет вызвана так скоро, как это возможно. Стоит учитывать что это не точное время, через которое вызовется функция, а скорее не раньше чем через это время. И не раньше чем освободится стек вызовов, очередь микрозадач и перерендер страницы.
* Ноль или больше значений, который будут переданы аргументами при вызове функции.

И setTimeout и setInterval возвращают идентификатор таймера. Это значение может быть использовано для того чтобы остановить таймер.

Для остановки таймера используются функции clearTimeout и clearInterval.

```javascript
    const timerId = setTimeout(() => {
        console.log(1);
    }, 10);

    clearTimeout(timerId);
    // Сообщение в консоль выведено не будет
```

## Рекурсивный setTimeout

Существует способ запускать что-то регулярно без использования setInterval. Это рекурсивный setTimeout.

```javascript
    /**
    setInterval(() => {
        console.log('repeat')
    }, 2000);
    */

    const repeat = () => {
        console.log('repeat');
        setTimeout(repeat, 2000);
    }

    setTimeout(repeat, 2000);
```

Отличия setInterval от рекурсивного setTimeout'а:

* Рекурсивный setTimeout гарантирует определенную задержку между окончанием выполнения кода и последующим вызовом. Задержка между следующим выполнением начнется только после того, как код закончит работу.
* Тоже самое с setInterval выполнится немного по-другому. Выбранный интервал будет включать в себя время выполнения функции. Таким образом, если выбран интервал 100 миллисекунд, а функция выполняется 40, пауза между вызовами будет 60 миллисекунд.
* Выполняя рекурсивный setTimeout можно задавать различный таймер для каждой итерации.

Давайте взглянем на эти отличия на примерах:

```javascript        
    let start = Date.now();

    const longTask = async () => {
        console.log((Date.now() - start) / 1000);
        start = Date.now();
        while(Date.now() - start < 400) {
            continue;
        }
    }

    setInterval(longTask, 500);
```

Функция longTask будет выполняться каждые 500 милисекунд. Между вызовами будет проходить 100 милисекунд. Если бы longTask выполнялась дольше чем заданный интервал, то задержки между вызовами не было бы вообще.

```javascript
    let start = Date.now();

    const longTask = async () => {
        console.log((Date.now() - start) / 1000);
        start = Date.now();
        while(Date.now() - start < 400) {
            continue;
        }
        setTimeout(longTask, 500);
    }

    setTimeout(longTask, 500);
```

Здесь каждый новый вызов longTask планируется в конце предыдущего и, как долго бы не выполнялась функция, задержка между вызовами будет 500 милисекунд.

Вернемся к первому примеру из начала курса

```javascript
    let i = 0;
    const start = Date.now();
    function increment() {
        for (let j = 0; j < 1e9; j++) {
            i++;
        }
        return `Выполнено за ${(Date.now() - start) / 1000} секунд`;
    }
    console.log(increment());
```

С помощью setTimeout можно выполнить данный скрипт без блокирования основного потока.
Мы разбиваем вычисления на более маленькие и запускаем их через вложенный setTimeout.
Вот так:

```javascript
    let i = 0;
    const start = Date.now();

    function asyncIncrement() {
        do {
            i++;
        } while (i % 1e6 !== 0);
        if (i == 1e9) {
            alert(`Выполнено за ${(Date.now() - start) / 1000} секунд`);
        } else {
            setTimeout(asyncIncrement);
        }
    }

    asyncIncrement();
```

Задачи:

* Какой будет порядок console.log?

```javascript
    console.log('start');

    setTimeout(() => {
        console.log('timeout 1');
    }, 200);
    
    setTimeout(() => {
        console.log('timeout 2');
    }, 100);

    setTimeout(() => {
        console.log('timeout 3');
    });

    console.log('end');
```

* Сделать виджет часов

* Написать функцию, принимающую на вход строку, и выводящую в div эту строку с эффектом печатанья. (Как в видеобанере на [tensor.ru](https://tensor.ru/))

* Есть поле ввода (`<input type="text">`). При вводе текста в input начинается поиск (при каждом изменении текста). Написать функцию, которая бы откладывала поиск на заданное количество миллисекунд при каждом вводе символа, чтоб поиск не начинался, пока пользователь не сдеалет достаточно долгую паузу во вводе или не закончит ввод.