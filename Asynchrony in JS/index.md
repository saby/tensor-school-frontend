# Асинхронность в JS

JavaScript - ***однопоточный язык программирования***, в котором может быть выполнено только что-то одно за раз. То есть, в одном потоке движок JavaScript может обработать только 1 оператор за раз.

Если какая-либо операция выполняется продолжительное время, вся программа остановит выполнение и будет ожидать ее завершения. Пока это происходит, вы не сможете взаимодействовать со страницей, будет ощущение, что вкладка зависла. Это называется ***блокированием потока***. 

Рассмотрим следующие примеры:
*       let i = 0;
        const start = Date.now();
        function increment() {
            for (let j = 0; j < 1e9; j++) {
                i++;
            }
            return `Выполнено за ${(Date.now() - start) / 1000} секунд`;
        }
        console.log(increment());

*       const start = Date.now();
        let xhr = new XMLHttpRequest();
        xhr.open('GET', '/long-responce', false);
        try {
            xhr.send();
            if (xhr.status != 200) {
                alert('Ошибка');
            } else {
                alert(`Выполнено за ${(Date.now() - start) / 1000} секунд`);
            }
        } catch(err) {
            alert("Запрос не удался");
        }

Если запустить эти 2 блока кода, произойдет блокирование потока. Давайте разберемся, почему так происходит и как можно этого избежать.

## Как JavaScript работает с синхронным кодом
Чтобы понять как JavaScript работает с синхронным кодом, нам нужно знать что такое ***стек вызовов***.

Под стеком вызовов подразумевается стек со структурой *LIFO*
(Last in, First Out / Последний вошел, первый вышел), который используется для хранения всех контекстов выполнения, созданных на протяжении исполнения кода. И, т.к. JavaScript - однопоточный язык программирования, - это означает, что имеется только один стек вызовов, а элементы могут добавляться и удаляться только с вершины этого стека.

Теперь давайте взглянем на следующий код для примера:

        function fn1() {
            console.log();
        }

        function fn2() {
            fn1();
        }

        function fn3() {
            fn2();
        }

        fn3();

И посмотрим как JavaScript будет с ним работать.
`(Пример кода под картинку с интерента. Можно привлечь дизайнеров и сделать свои)`

![callstack](./resources/callstack.gif)

Когда код начал выполняться, был создан глобальный контекст выполнения (представленный как main()) и добавлен на вершину стека вызовов.

Когда встречается вызов функции fn3(), он так же добавляется на вершину стека. Далее идет вызов функции fn2(), она помещается на вершину стека. Далее идет вызов fn1(), он помещается на вершину стека. Далее, на вершину стека вызовов помещается console.log(), после выполнения он удаляется из стека. Затем функция fn1() завершена и удаляется из стека. Тоже самое происходит и с fn2(), затем fn1().

Выполнение программы заканчивается, поэтому глобальный контекст вызова (main()) удаляется из стека.

## Как JavaScript работает с асинхронным кодом
Чтобы понять как JavaScript работает с асинхронным кодом, нам нужно знать что такое ***цикл событий или Event Loop***.

Алгоритм работы цикла событий:
1. Выполнить первую в очереди задачу из очереди м**И**крозадач
    * делать это пока очередь не будет пуста (в процессе выполнения микро задач, очередь может пополняться)
    * при отсутствии задач в очереди пропустить шаг
2. Выполнить перерендер страницы при необходимости.
3. Выполнить первую в очереди задачу из очереди м**А**крозадач
    * при отсутствии задач в очереди пропустить шаг
4. Повторить цикл

`Асинхронность в JavaScript – это не встроенная возможность языка, а API, которое предоставляется средой выполнения (Браузер, Node.js).`

`(Хочется сделать пример кода с гифкой как в примере выше, нужны дизайнеры)`

        console.log('start');

        setTimeout(function timeOutCallback() {
            console.log('timeout callback');
        });

        const pr = new Promise(function promiseConstr(res) {
            console.log('promise constructor');
            res();
        });

        pr.then(function promiseCallback() {
            console.log('promise callback');
        });

        console.log('end');

![eventloop](./resources/eventloop.gif)

Когда код начал выполняться, был создан глобальный контекст выполнения (представленный как main()) и добавлен на вершину стека вызовов. Далее, на вершину стека вызовов помещается console.log('start'), после выполнения он удаляется из стека.

Следующая вызывается функция setTimeout() и помещается на вершину стека. setTimeout() запускает таймер на указанное время и с помощью web API, помещает timeOutCallback в очередь макрозадач.

На этом этапе, setTimeout() завершается и удаляется из стека. После этого, в стек добавляется конструктор промиса. Далее, на вершину стека вызовов помещается console.log('promise constructor'), после выполнения он удаляется из стека. Тоже самое с происходит с вызовом res().

Затем встречается вызов обработчика промиса .then(). Он помещается на вершину стека вызовов, выполняется и добавляет promiseCallback в очередь микрозадач.

Далее, на вершину стека вызовов помещается console.log('end'), после выполнения он удаляется из стека.

Выполнение заканчивается, поэтому глобальный контекст вызова (main()) удаляется из стека.

Далее в ход вступает Event Loop.

В очереди микрозадач есть задача и промис, на который был повешен этот обработчик, и т.к. промис разрешился, его можно выполнять.
Создается глобальный контекст выполнения (представленный как main()) и добавляется на вершину стека вызовов. Далее promiseCallback() помещается на вершину стека вызовов. Далее, на вершину стека вызовов помещается console.log('promise callback'), после выполнения он удаляется из стека. Затем функция promiseCallback() завершена и удаляется из стека. Выполнение заканчивается, поэтому глобальный контекст вызова (main()) удаляется из стека.

Смотрим снова в очередь микрозадач. Она пуста. Переходим к следующему шагу. Перерисовка страницы не требуется. Переходим к следующем шагу.

В очереди макрозадач есть задача. Таймер установленный на таймауте истек. Создается глобальный контекст выполнения (представленный как main()) и добавляется на вершину стека вызовов. 
Далее timeOutCallback() помещается на вершину стека вызовов. Далее, на вершину стека вызовов помещается console.log('timeout callback'), после выполнения он удаляется из стека. Затем функция timeOutCallback() завершена и удаляется из стека. Выполнение заканчивается, поэтому глобальный контекст вызова (main()) удаляется из стека.

##setTimeout и setInterval

Web платформа предоставляет языку JavaScript несколько функций позволяющих выполнять код асинхронно после определенного интервала времени, и многократно выполнять блок кода асинхронно, пока выполнение не будет остановлено.

    setTimeout(callback[, timeout, ...args]) // Выполняет определенный блок кода единожды, после завершения указанного времени.
    setInterval(callback[, timeout, ...args]) //Выполняет определенный блок кода многократно с определенной временной задержкой между каждым вызовом.

Аргументы принимаемые этими функциями:

* Функция или ссылка на функцию
* Число в миллисекундах, определяющее задержку вызова функций. Если передать 0 или опустить значение, функция будет вызвана так скоро, как это возможно. Стоит учитывать что это не точное время, через которое вызовется функция, а скорее не раньше чем через это время. И не раньше чем освободится стек вызовов
* Ноль или больше значений, который будут переданы аргументами при вызове функции.

И setTimeout и setInterval возвращают идентификатор таймера. Это значение может быть использовано для того чтобы остановить таймер.

Для остановки таймера используются функции clearTimeout и clearInterval.

        const timerId = setTimeout(() => {
            console.log(1);
        }, 10);

        clearTimeout(timerId);
        // Сообщение в консоль выведено не будет

### Рекурсивный setTimeout

Существует способ запускать что-то регулярно без использования setInterval. Это рекурсивный setTimeout.

        /**
        setInterval(() => {
            console.log('repeat')
        }, 2000);
        */

        const repeat = () => {
            console.log('repeat');
            setTimeout(repeat, 2000);
        }

        setTimeout(repeat, 2000);

Отличия setInterval от рекурсивного setTimeout'а:

* Рекурсивный setTimeout гарантирует определенную задержку между окончанием выполнения кода и последующим вызовом. Задержка между следующим выполнением начнется только после того, как код закончит работу.
* Тоже самое с setInterval выполнится немного по-другому. Выбранный интервал будет включать в себя время выполнения функции. Таким образом, если выбран интервал 100 миллисекунд, а функция выполняется 40, пауза между вызовами будет 60 миллисекунд.
* Выполняя рекурсивный setTimeout можно задавать различный таймер для каждой итерации.

Давайте взглянем на эти отличия на примерах:
        
        let start = Date.now();

        const longTask = async () => {
            console.log((Date.now() - start) / 1000);
            start = Date.now();
            while(Date.now() - start < 400) {
                continue;
            }
        }

        setInterval(longTask, 500);

Функция longTask будет выполняться каждые 500 милисекунд. Между вызовами будет проходить 100 милисекунд. Если бы longTask выполнялась дольше чем заданный интервал, то задержки между вызовами не было бы вообще.
        
        let start = Date.now();

        const longTask = async () => {
            console.log((Date.now() - start) / 1000);
            start = Date.now();
            while(Date.now() - start < 400) {
                continue;
            }
            setTimeout(longTask, 500);
        }

        setTimeout(longTask, 500);

Здесь каждый новый вызов longTask планируется в конце предыдущего и, как долго бы не выполнялась функция, задержка между вызовами будет 500 милисекунд.

Задачи:

* Какой будет порядок console.log?

        console.log('start');

        setTimeout(() => {
            console.log('timeout 1');
        }, 200);
        
        setTimeout(() => {
            console.log('timeout 2');
        }, 100);

        setTimeout(() => {
            console.log('timeout 3');
        });

        console.log('end');

* Сделать виджет часов

* Написать функцию, принимающую на вход строку, и выводящую в div эту строку с эффектом печатанья. (Как в видеобанере на tensor.ru)

* Есть инпут. При вводе текста в инпут начинается поиск (при каждом изменении текста). Написать функцию, которая бы откладывала поиск на заданное количество миллисекунд при каждом вводе символа, чтоб поиск не начинался, пока пользователь не закончит ввод.

## Web worker

Web Worker средство для запуска скриптов в фоновом потоке, отличном от основного потока. Следовательно задачи, выполняемые ими, не блокируют цикл событий. Поэтому они отлично подходят для выполнения тяжелых в вычислительном плане и длительности задач.
Web Worker'ы не являются частью JavaScript. Они представляют собой возможность браузера, к которой можно получить доступ посредством JavaScript.

У Веб-воркеров есть некоторые ограничения:
* Веб-воркеры выполняются в изолированных потоках в браузере. Как результат, код, который они выполняют, должен быть включён в отдельный файл.
* Веб-воркеры не имеют доступ к DOM-дереву.
* У них не определен объект window, в контексте воркера и self, и this, указывают на глобальное пространство имён для воркера.

### Создание воркера

        const worker = new Worker(aURL [, options]);

* aURL - URL-адрес скрипта который будет выполняться. Он должен подчиняться политике одного источника.
* options (необязательный) - объект с опциями

### Передача сообщений в/из выделенного worker
Чтобы передать сообщение в выделенный воркер, нужно вызвать на нем метод *postMessage*

        worker.postMessage(message, [transfer]);

* message - объект передаваемый в worker. Будет содержаться в поле data.
* transfer (необязательный) - массив с передаваемыми Transferable объектами (из тех, что были указаны в message) на которые передаются права собственности. Если право на объект передаётся, он становится непригодным в контексте, из которого был отправлен, и становится доступным только в worker, которому он был отправлен.

Внутри воркера сообщения наружу передаются точно также.

Чтобы получить переданное сообщение в воркере, нужно подписаться на событие *message*

        self.addEventListener('message', function(e) {
            // e.data - message, переданный в воркер
            // self.postMessage(message); - передать данные наружу
        });

Чтобы снаружи получить переданное из воркера сообщение, нужно на воркере подписаться на событие *message*

        worker.addEventListener('message', function(e) {
            // e.data - message, переданный из воркера
        });

Чтобы обработать ошибку, возникшую в процессе выполнения воркера, используется подписка на событие *error*

        worker.addEventListener('error', function(e) {
            e.filename — имя файла со скриптом, в котором ошибка произошла.
            e.lineno — номер строки в файле, в котором произошла ошибка.
            e.message — cообщение об ошибке в читаемом виде.
        });

### Завершение работы worker-а
    
Прикращение работы воркера из главного потока происходит вызовом метода *terminate* на экземпляре выделенного воркера.

    worker.terminate();
    
Прикращение работы воркера внутри воркера происходит вызовом метода *close*.

    self.close();

Вернемся к первому примеру из начала курса

        let i = 0;
        const start = Date.now();
        function increment() {
            for (let j = 0; j < 1e9; j++) {
                i++;
            }
            return `Выполнено за ${(Date.now() - start) / 1000} секунд`;
        }
        console.log(increment());

С помощью веб воркера можно просто выполнить данный скрипт без блокирования основного потока.
Перенесем данный код в отдельный файл и поместим вызов функции *increment* внутрь обработчика *message*
Вот так:

        // myWorker.js

        let i = 0;
        const start = Date.now();

        function increment() {
            for (let j = 0; j < 1e9; j++) {
                i++;
            }
            return `Выполнено за ${(Date.now() - start) / 1000} секунд`;
        }

        self.addEventListener('message', function(e) {
            if (e.data.cmd === 'calculate') {
                const result = increment(); // выполняем вычисления
                self.postMessage(result); // отправляем результат
                self.close(); // завершаем работу
            }
        });

В основном потоке создадим воркер и дадим команду на выполнение данных вычислений:

        const worker = new Worker('./myWorker.js');

        worker.addEventListener('message', function(e) {
            console.log(e.data);
        });

        worker.postMessage({cmd: 'calculate'});
