# Отладка HTML и CSS 
## HTML
Особенность HTML состоит в том, что он не компилируется в другой формат перед отображением браузером (он является интерпретируемым, а не компилируемым).    
Браузеры анализируют и обрабатывают HTML более толерантно, в сравнении с языками программирования, интерпретирующими код строже.

Что же значит толерантность в контексте обработки HTML?

Браузер всегда будет стараться исправить ошибки программиста или верстальщика, чтобы конечный пользователь увидел страницу. 

В это состоит и преимущество браузера для пользователя, и значительный недостаток для разработчика.

Когда мы говорим о коде, как правило основной пул ошибок, с которыми сталкивается программист - это:
>Синтаксические ошибки - ошибки в правильности написания.    

Такие ошибки обычно легко исправить, проанализировав текст исключения.

>Логические ошибки - ошибки непосредственно в алгоритмах программы.    

Такие исправлять сложнее, чем синтаксические, поскольку никаких исключений явно не выдается и, как правило, приходится пощагово отлаживать ход выполнения.

HTML не страдает от синтаксических ошибок, потому что браузер читает код толерантно.    
Даже если верстка написана некорректно - браузер все равно отобразит страницу в том или ином виде, поскольку они имеют встроенные правила по интерпретации неверно написанной разметки.

Рассмотрим на примере:
```html
    <h1>Ошибки разметки</h1>
    <p>Какого рода ошибки можно допустить в HTML?
    <ul>
        <li>
            Незакрытые теги. 
            Если тег <strong>не закрыт как положено - его действие может распространяться на лишние области.
        </li>
        <li>
            Некорректно описанная вложенность элементов. 
            <strong>strong <em>strong emphasised?</strong> what is this?</em>
        </li>
        <li>Незакрытые атрибуты <a href="https://www.google.com/>Поиск</a></li>
    </ul>
```

Приведенный код содержит следующий набор проблем:
1. У параграфа и элемента списка не закрыты теги.  
   На изображении выше видно, что разметка не пострадала, так как браузеру легко сделать вывод о том, где заканчивается один элемент и начинается другой.
2. Первый \<strong> элемент также не имеет закрывающего тега.    
   Это уже более проблематично, так как сложно сказать, где элемент должен заканчиваться.
3. Следующая часть нарушает правила вложенности - теги \<strong> и \<em> пересекаются.    
```html
    <strong>strong <em>strong emphasised?</strong> what is this?</em>
```
4. В атрибуте href отсутствует закрывающая двойная кавычка.

Посмотрим что визуально отобразил нам браузер.

![src/Untitled.png](resources/html_syntax_error.png)

Откроем сгенерированный браузером HTML через Chrome DevTools (правой кнопкой мышки кликаем на элемент, нажимаем Inspect) - откроется представление DOM-дерева.

![src/Untitled.png](resources/html_syntax_browser.png)

Если сравнить разметку из кода и результат браузера - видно, что разметка не совпадает.
Браузер как смог исправил ошибки в нашей верстке:
1. Добавил закрывающий тег <\p>,
```html
    <p>Какого рода ошибки можно допустить в HTML?</p>
```
2. Поправил некорректную вложенность,
```html
    <p>Какого рода ошибки можно допустить в HTML?</p>
```
3. Вырезал некорректные элементы - тега \<a> в результирущей верстке просто нет.

При этом никаких ошибок в консоли или где-то еще браузер не выдал, поэтому следует *настроить дополнительную проверку верстки на валидность* в своей IDE.

---
Отдельно стоит отметить, что *поведение разных браузеров различается*.   
Методика "исправления" ошибок верстки также может быть разной, поэтому следует проверять верстку и стили во всех целевых браузерах, для которых вы пишете свой код.
---

Несмотря на то, что ошибки верстки бруазером явно не показываются - инструменты отладки весьма и весьма полезны при работе с версткой.

Помимо простого просмотра структуры DOM-дерева в инструментах отладки браузер предоставляет возможность модифицировать состав тегов и стилей на лету без перезагрузки страницы.

Также очень удобен в использовании режим поиска DOM-элемента по самой странице:
1. Откройте инструменты отладки,
2. Нажмите на иконку курсора - после этого ховером можно выделить любой элемент на странице, 
3. Кликнув на него, вы перейдете к выбранному элементу на вкладке Elements.  

![src/Untitled.png](resources/elements_visual_search.png)

Подробнее познакомиться с работой вкладки Elements можно [тут](https://developer.chrome.com/docs/devtools/dom/).


---
## CSS
На примере другого HTML разберемся какие проблемы могут быть с CSS и какие средства дает нам браузер для их решения: 
```html
<h1>Список студентов</h1>
<ul>
    <li>
       <span class="name">Иванов</span>
       <span class="mark">5</span>
    </li>
    <li>
       <span class="name">Петров</span>
       <span class="mark">4</span>
    </li>
    <li>
       <span class="name">Сидоров</span>
       <span class="mark">5</span>
    </li>
</ul>
```
```css
li {
   font-style: italic;
}
.mark {
   margin: 0 4px;
   font-weight: bold;
   color: navy;
}
.top {
   color: green;
}
.medium {
   color: orange;
}
.low {
   color: red;
}
```
Проинспектировав конкретный элемент в браузере - сразу можно увидеть достаточно исчерпывающий обьем информации:
* тип элемента и список примененных классов,
* размеры элемента,
* цветными рамками выделены отступы элемента,
* список примененных стилей,
  * стили, которые перебиты более сильными правилами, перечеркнуты и легко визуально отличимы.
  * все свойства с цветами визуально отображены в палитре.

![src/Untitled.png](resources/html_element_css.png)

Что позволяет очень наглядно и легко можно отследить ситуации с неверным приоритетом применения правил на элементы.

Помимо этого на вкладке Styles есть возможность:
>* редактирования стилей на ходу,
>* применения псевдоклассов,
>* добавления новых стилей.

Редактирование стилей реализовано максимально интерактивно - браузер подсказывает все варианты свойств и их значений.

![src/Untitled.png](resources/css_autocomplete1.png)
![src/Untitled.png](resources/css_autocomplete2.png)


Также есть возможность просмотреть набор вычисленных стилей, которые действительно повлияли на отображение элемента на вкладке Computed в компактном виде.

![src/Untitled.png](resources/html_css_computed.png)

При необходимости в некоторых ситуациях управление набором классов и обработкой событий на элементе переходит в руки JS.   
Доступ к DOM-дереву через стандартное API ничем не ограничен и любой скрипт может получить доступ к элементу.  
Таким образом отследить точку изменения элемента с ростом приложения становится все сложнее.
Для этих целей в инструментах браузера есть возможность:
* устанавливать точки остановки для изменений DOM-дерева,

![src/Untitled.png](resources/html_dom_breakpoints.png)
* просматривать обработчики событий элементов

![src/Untitled.png](resources/html_event_listeners.png)
