# Утечки памяти
Браузер в ходе работы хранит объекты в памяти, пока они могут быть доступны в скрипте напрямую или по ссылке.      
>Сборщик мусора - это фоновый процесс в движке JavaScript, который определяет недоступные более объекты, удаляет их и вывобождает память.

Утечка памяти происходит, когда объект в памяти, который должен быть очищен сборщиком мусора, остается доступным через непреднамеренную ссылку из другого объекта.     
Хранение избыточных объектов в памяти приводит к избыточному расходу памяти и может привести к снижению производительности.

Утечки памяти - это уже повышенный уровень сложности ошибки, их поиск может занимать значительное время.   
Самое интересное, что сама по себе утечка памяти по сути не является исключением, поэтому браузер не выдает никаких явных ошибки.

Основное проявление утечки - снижение производительности страницы производительность нашей страницы постепенно ухудшается и в итоге может произойти краш страницы.

## Примеры утечек
Рассмотрим базовые причины возникновения утечек памяти.

### Случайные глобальные переменные
Глобальные переменные всегда доступны из корня скрипта и никогда не будут очищены сборщиком мусора.      
Некоторые ошибки вызывают утечку переменных из локальной области в глобальную область в нестрогом режиме:
* присвоение значения необъявленной переменной,
* использование ключевого слова this, которое указывает на глобальный объект.
```javascript
function createGlobalVariables() {
    memoryLeak1 = 'Утечка памяти №1';
    this.memoryLeak2 = 'Утечка памяти №2';
}
createGlobalVariables();
console.log(memoryLeak1, memoryLeak2);
```
Ошибки такого рода исключаются использованием строгого режима ```'use strict'```.
С ним приведенный код выдаст ошибку, потому что переменные не объявлены явно.

### Замыкания
Переменные в локальной области видимости любой функции будут очищены после того, как:
* функция вышла из стека вызовов, 
* за пределами функции не осталось ссылок, указывающих на них.

Если ссылки остались - замыкание будет держать переменные в памяти, хотя сама функция уже завершила выполнение.

```javascript
function addMessage() {
    const hugeArray = [];
    return function add() {
        hugeArray.push('Message');
    }
}

function repeat(fn, count) {
    for (var i = 0; i < count; ++i) {
        fn();
    }
}

const doAdd = addMessage();
repeat(doAdd, 1000);

```
В этом примере массив hugeArray никогда не возвращается ни из одной из функций, извне к нему никто не имеет доступа.
Тем не менее его размер может бесконечно увеличиваться с каждым вызовом add(). 

Т.е. такое обращение с переменной внутри многократно вызываемой функции не дает результатов, но сильно нагружает память.

Как это предотвратить:
* отслеживать, когда замыкание было создано и что оно удерживает в памяти,
* понять ожидаемую продолжительность жизни и использования замыкания.

### Таймеры
Наличие setTimeout/setInterval, ссылающихся на объект в колбэке, является очень распространенной причиной утечки памяти.

Если установить повторяющийся рекурсивный таймер или интервал в коде - ссылка на такой объект будет активной пока есть возможность, что вызов сработает.

Ниже приведен пример кода, где объект ```data``` очиститься только после очистки таймера. 

Поскольку setInterval продолжает свою работу и вызывается каждую секунду - ```data``` нельзя очистить.

А значит и data.hugeString сохраняется в памяти пока страница жива, даже если им никто не пользуется.

```javascript
function setCallback() {
    const data = {
        counter: 0,
        hugeString: new Array(1000).join('+')
    };
    return function cb() {
        data.counter++;
    }
}
setInterval(setCallback(), 1000);
```
Как это предотвратить:
* внимательно следить за списком объектов, которые используются внутри колбэков таймера,
* если таймер уже не актуален - обязательно очищать его через clearInterval/clearTimer.

```javascript
const intervalId = setInterval(setCallback(), 1000);
// ...
clearInterval(intervalId);
```
### Подписчики на события
Активный слушатель событий, добавленный с помощью метода addEventListener() не даст сборщику мусора избавиться от всех переменных, существующих в его области видимости.   
После добавления слушатель событий будет жить до тех пор, пока:

* не будет явно удален через removeEventListener(),
* или связанный с ним DOM-элемент не будет удален.

Для некоторых типов событий ожидается, что они будут сохраняться до тех пор, пока страница не будет закрыта.

Однако иногда требуется, чтобы слушатель событий выполнялся определенное количество раз или пока идет какой-то внутренний процесс.
```javascript
class Subscriber {
    constructor() {
        document.addEventListener('click', () => {
           console.log('Я получил событие'); 
        });
    }
}

let subscriber1 = new Subscriber();
subscriber1 = null;
```
Со временем сборщик мусора вроде как должен очистить все упоминания экземпляра Subscriber, но подписка на событие document никуда не денется.

Поэтому при избавлении от объекта необходимо явно вызвать отписку.
```javascript
class Subscriber {
    constructor() {
        this._clickHandler = () => {
            console.log('Я получил событие');
        };
        document.addEventListener('click', this,_clickHandler);
    }
    
    destroy() {
        document.removeEventListener('click', this._clickHandler);
    }
}

let subscriber1 = new Subscriber();
subscriber1.destroy();
subscriber1 = null;
```

### Detached элементы
Если узел DOM имеет прямые ссылки из JavaScript - сборщик мусора не сможет удалить элемент из памяти.

```javascript
function createElement() {
    const div = document.createElement('<div>');
    div.id = 'detached';
    return div;
}

const detachedDiv = createElement();
document.body.appendChild(detachedDiv);
document.body.removeChild(document.getElementById('detached'));
```

Как это предотвратить?

Одним из возможных решений является перемещение ссылок DOM в локальную область функции.   
В приведенном ниже примере переменная, указывающая на элемент DOM, удаляется после завершения функции appendElement()

```javascript
function createElement() {
    //...
}
function appendElement() {
    const detachedDiv = createElement();
    document.body.appendChild(detachedDiv);
}
document.body.removeChild(document.getElementById('detached'));
```

## Как искать утечки памяти
Под инструменты поиска утечек памяти в Chrome DevTools выделена отдельная вкладка Memory.

![src/Untitled.png](resources/memory.png)

Поскольку сборщик мусора работает в фоне - иногда требуется ручной запуск, его можно произвести по кнопке с мусорным ведром в левой части. 

Для отладки утечки памяти требуется локализовать хотя бы примерный сценарий, когда происходит ощутимый провал производительности страницы.  
Проще всего локализовать подобный сценарий можно простым повторением одних и тех же действий большое количество раз.
Какой бы тип профилирования вы не выбрали - базовый сценарий поиска утечки остается таким же.

Подробнее мы рассмотрим Heap snapshot и Allocation timeline.

> Важно: для более точного поиска утечки рекомендуется работать в режиме Инкогнито.

### Heap snapshot
Heap snapshot представляет собой снятие "слепка" текущих объектов, хранящихся в памяти.

Для того чтобы отследить накапливаемые объекты - требуется делать несколько последовательных снимков.

Если ваш сценарий предполагает загрузку каких-то статических файлов - предварительно стоит загрузить их с сервера.

Далее:
1. Первый снимок делаем без воспроизведения сценария,
2. Затем второй снимой делаем уже после вопроизведения предположительного сценария,
3. Сравниваем состояние памяти по зафиксированным снимкам.

![src/Untitled.png](resources/memory_snapshot_comparison.png)

>**Shallow size** - это объем памяти, удерживаемой под сам объект.  
>**Retained size** - это объем памяти, который высвободится, если удалить объект и его связанные объекты, которые больше ниоткуда недоступны.

Чем больше Retained size объекта - тем критичнее его сохранность в памяти.  

Для каждой в списке созданных обьектов можно просмотреть его "источник" - по нему и следует анализировать точку возникновения утечки.

![src/Untitled.png](resources/memory_detached_path.png)

### Allocation Timeline
В случае работы с Allocation Timeline анализ утечек памяти идет по временной шкале.     
Вы запускаете запись таймлайна и начинаете повторять предположительный сценарий снова и снова.      
Созданные в ходе работы объекты отображаются в виде синих столбиков, чем выше столбик - тем больше памяти было ихрасходовано.       
Со временем запускается сборщик мусора и объекты, созданные на предыдущих воспроизведениях сценария должны исчезать.    
Если какая-то часть объектов не исчезает - вероятно в этом месте и есть утечка памяти.

![src/Untitled.png](resources/memory_detached_path.png)
